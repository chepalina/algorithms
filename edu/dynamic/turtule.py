# Вывести маршрут максимальной стоимости
# В левом верхнем углу прямоугольной таблицы размером N×M находится черепашка.
# В каждой клетке таблицы записано некоторое число.
# Черепашка может перемещаться вправо или вниз,
# при этом маршрут черепашки заканчивается в правом нижнем углу таблицы.
#
# Подсчитаем сумму чисел, записанных в клетках,
# через которую проползла черепашка (включая начальную и конечную клетку).
# Найдите наибольшее возможное значение этой суммы и маршрут, на котором достигается эта сумма.
#
# Входные данные
# В первой строке входных данных записаны два натуральных числа N и M,
# не превосходящих 100 — размеры таблицы. Далее идет N строк,
# каждая из которых содержит M чисел, разделенных пробелами — описание таблицы.
# Все числа в клетках таблицы целые и могут принимать значения от 0 до 100.
#
# Выходные данные
# Первая строка выходных данных содержит максимальную возможную сумму,
# вторая – маршрут, на котором достигается эта сумма.
# Маршрут выводится в виде последовательности, которая должна
# содержать N-1 букву D, означающую передвижение вниз и M-1 букву R,
# означающую передвижение направо.
# Если таких последовательностей несколько, необходимо вывести ровно одну (любую) из них.

# Разбор
# В этой задаче используется двумерная динамика, описывающаяся следующим образом:
# • База динамики: начальное состояние черепашки, то есть, число монет,
# которое она соберёт, не двигаясь с места - dp0,0 = f0,0
# • Состояние динамики: число монет, которое черепашка соберёт на текущем ходу dpi,j
# • Переход динамики: черепашка может ходить только вниз и влево,
# поэтому мы хотим брать максимум из двух предыдущих состояний -
# dpi,j = max(dpi−1,j , dpi,j−1) + fi,j
# • Обход выполняется последовательно по всем клеткам массива,
# результат находится в правой нижней клетке массива динамики
# При решении следовало обратить внимание на крайние случаи при заполнении динамики
# (например, в крайнем левом столбце и краней верхней строке).
# Эту проблему можно решать двумя способами -
# добавлением фиктивных столбца и строки либо предподсчётом значений до запуска основного
# цикла обхода.
# Асимптотика решения: O(N × M)


# Примеры
# входные данные
# 5 5
# 9 9 9 9 9
# 3 0 0 0 0
# 9 9 9 9 9
# 6 6 6 6 8
# 9 9 9 9 9
# выходные данные
# 74
# D D R R R R D D


# [9, 18, 27, 36, 45]
# [12, 18, 27, 36, 45]
# [21, 30, 39, 48, 57],
# [27, 0, 0, 0, 0],
# [36, 0, 0, 0, 0]]


def max_cost(array: list[list[int]]):
    dp = [[0] * len(array[0]) for _ in range(len(array))]
    path = []

    print("init - ", dp)

    # верхняя строка
    prev = 0
    for i in range(len(dp[0])):
        dp[0][i] = prev + array[0][i]
        prev = dp[0][i]
    print("top - ", dp)

    # левая строка
    prev = 0
    for i in range(len(dp)):
        dp[i][0] = prev + array[i][0]
        prev = dp[i][0]

    print("left - ", dp)


    # динамика
    for i in range(1, len(dp)):
        for j in range(1, len(dp[i])):
            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + array[i][j]

    print("full - ", dp)

    i, j = len(dp)-1, len(dp[0])-1

    while i > 0 or j > 0:
        if i == 0:
            path.append("R")
            j -= 1
        elif j == 0:
            path.append("D")
            i -= 1
        elif dp[i-1][j] > dp[i][j-1]:
            path.append("D")
            i -= 1
        else:
            path.append("R")
            j -= 1

    path.reverse()
    return dp[-1][-1], " ".join(path)


arr = ["9 9 9 9 9".split(" "),
       "3 0 0 0 0".split(" "),
       "9 9 9 9 9".split(" "),
       "6 6 6 6 8".split(" "),
       "9 9 9 9 9".split(" "),
       ]

for item in arr:
    for j in range(len(item)):
        item[j] = int(item[j])

print(max_cost(arr))
